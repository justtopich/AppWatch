# AppWatch

[AppWatch](https://github.com/justtopich/AppWatch) оповещает о падении REST приложений и перезапускает их.
Возможности:

- Отслеживание свободного места на диске

- Отслеживание логов

- Отслеживание процессов приложений

- Проверка отклика HTTP запросов

- Запуск приложений или служб или сторонних скриптов или произвольных команд

- Оповещение о событиях через сторонние сервисы (email, slack, discord)

- Добавление других сервисов с помощью своих коннекторов

[Руководство по созданию своих коннекторов](Connectors.md)



## Предназначение

Позволяет автоматизировать проверку работы web-приложений. Если приложение не работает или зависло (процесс активен, но не отвечает на запросы HTTP), то попытается перезапустить его и вышлет вам оповещение.

Оповещения так же могут высылаться при обнаружении заданных слов в логах приложений или при уменьшении свободного места на диске.



## Установка и настройка

При отсутствии конфигурационного файла **AppWatch.cfg** , приложение автоматически создаст новый с примерами настроек.

Конфигурационный файл состоит из секций, в котором есть параметры относящейся к ней и имеет следующую структуру:

```ini
[Секция1]
Параметр=значение
Параметр1=значение

[Секция2]
Параметр=значение
Параметр1=значение
```

Название каждой секции обозначено квадратными скобками `[]`. Секции не должны повторяться и могут находится в любом порядке. Параметр относится к секции до тех пор, пока не будет объявлена новая.



### Основные

Параметры службы в секции **[service]**:

| **Параметр** | **Описание** |
| --- | --- |
| name | Имя службы. Оно используется для идентификации службы и будет отображаться в диспетчере задач. |
| displayName | Название службы которое будет отображаться в диспетчере служб. |
| description | Описание службы |

Эти параметры используются для удаления и установки службы.

Установка, удаление и изменение службы производится через исполняемый файл с правами администратора.

Вызовите исполняемый файл:

> appwatch.py ***key***
>

Где вместо **key** используется один из доступных ключей:

| Ключ    | Описание                    |
| --- | --- |
| install | установка службы. Доступно для Windwis и Linux платформ |
| remove | удалить службу |
| update | обновить службу |
| run | запуск приложения в консоли |
| doc | экспорт документации в папку docs |

После создания службы можете задать ей тип запуска &quot;автоматически&quot;. Служба должна запускаться от имени администратора.

На Linux для работы службы возможно придётся отключить SELinux.

Для логирования доступны следующие параметры секции **[logging]**:

| **Параметр** | **Описание** |
| --- | --- |
| enable | Булево значение. При **False** события отображаются только в консоли |
| loglevel | Уровень событий которые будут записаны.<br>**Full** - запись всех событий включая _debug._ <br>**Normal** - запись событий уровня _info_ и выше. |
| logmaxsizekbs | Максимальный размер файла журнала. При достижении заданного лимита запись начнётся в новый файл, а предыдущий будет переименован. |
| logmaxfiles | Максимальное количество файлов журнала. При достижении заданного лимита AppWatch будет удалять самые первые переименованные файлы. |



### Оповещения

Сведения о сервере в секции **[notify]**:

| **Параметр** | **Описание** |
| --- | --- |
| localName | Название сервера |
| localip | Ip адрес сервера |
| resendTimeoutM | Минимальное время между отправки уведомлениями |
| type | коннектор к сервису рассылки |
| useProxy | отправлять оповещения через прокси сервер |

AppWatch предоставляет три коннектора: email, slack и discord. Вы можете добавить свои коннекторы используя [Руководство по созданию своих коннекторов](Connectors.md).

При повторном возникновения одного и того же события, уведомление по нему не будет отослано если не прошло заданное в **resendTimeoutM** время.

Если указали **type=email** то задайте настройки почты в секции **[email]**:

| **Параметр** | **Описание** |
| --- | --- |
| sendTo | Почта на которую высылать уведомления |
| server | Адрес и порт smtp сервера. |
| port ||
| useSSL |Использовать защищённое соединение|
| user | Логин и пароль для авторизации на smpt сервере |
| password ||
| fromHeader | Заголовок письма. <br>**Pantsu Alarm \<bot@pantsumail.ru\>** |

Некоторые сервисы требуют разрешение на подключение сторонних приложений. Например для gmail нужно разрешить небезопасные приложения.

Если используете **slack** или **discord**, тогда задайте параметры в их секции:

| **Параметр** | **Описание** |
| --- | --- |
| url | WEBHOOK URL вашего приложения |

Если указали **useProxy=True** то задайте настройки прокси в секции **[proxy]**:

| **Параметр** | **Описание** |
| ------------ | ------------ |
| http         | *host:port*  |
| https        | *host:port*  |

Можно указать один или оба параметра.



#### Шаблоны оповещений

Для каждого события можно использовать свой шаблон текста, который будет отсылаться. В них можно ссылаться на различные данные. По умолчанию доступны:

| Переменная | Значение                                                |
| ---------- | ------------------------------------------------------- |
| break      | перевод на новую строку                                 |
| localName  | Название сервера                                        |
| localIp    | ip адрес сервера                                        |
| diskUsage  | Диск за которым следит AppWatch                         |
| diskFree   | Размер свободного места на диске в GB                   |
| diskWarn   | Количество свободного места для отправки предупреждения |
| critFree   | Количество свободного места для отправки оповещения     |
| app        | имя процесса по которому создано оповещение             |

Чтобы вставить эти переменные в текст, укажите их в **{{ }}** Например:

 `Сервер {{localName}} в большой беде!`

Шаблоны настраиваются через **templates.cfg**. Каждая секция отвечает за конкретный модуль.

| Шаблон | Событие |
| -------------- | ------- |
||**disk_inspector**         |
| critFree      | Закончилось место на диске |
| diskWarn       | Заканчивается место на диске |
|           | **email** |
| subject      | заголовок письма |
|  | **log_inspector** |
| error | сработал шаблон парсера логов |
|  | **process_inspector** |
| alive | процесс вернулся к работе без участия AppWatch |
| badAnswer | процесс не ответил на запрос или вернул неверный ответ |
| notFound | обязательный процесс не найден |



### Задания

Активные задания указываются в секции **[taskList]:**

| **Параметр** | **Описание** |
| --- | --- |
| intervalCheckMin | Интервал проверки в минутах. AppWatch выполнит все задания и заснёт на заданное время. |
| active | количество активных заданий |

Перечисление заданий начинается от **1**

```ini
[taskList]
intervalCheckMin = 10
active = 2
; 1 = diskUsage
1 = myApp
2 = MyHttpServer
```

Названия заданий должны совпадать с их секциями.



#### диск: свободное место

AppWatch может отслеживать используемое место на локальных дисках. Для каждого диска укажите два порога оставшегося свободного места, для которых будет использован свой шаблон оповещения из **templates.cfg**:

| **Параметр** | **Описание** |
| --- | --- |
| disk | Диск для отслеживания<br> *C:\\* |
| warning | Количество свободного в GB. Шаблон **diskWarn** |
| critical | Количество свободного в GB. Шаблон **critFree** |



#### парсер логов

AppWatch может проверять текстовые файлы на наличие ключевых слов. При нахождении таких слов будет создано оповещение. Для каждого файла создайте задание с параметрами:

| **Параметр** | **Описание**                                                 |
| ------------ | ------------------------------------------------------------ |
| file         | путь до файла                                                |
| templates    | список шаблонов по которым будет производится поиск<br>*template1; template2* |

Для одного такого задания можно указать несколько ключевых слов. Они задаются в **templates.cfg** в секции **[log_inspector]**. Например, если `templates = event1; event2`, то нужно создать эти шаблоны:

```ini
[log_inspector]
error = На сервере {{localName}} у приложения {{app}} проблемы
event1 = critical error
event2 = No license found
```

**error**  является шаблоном для оповещения. **event1** и **event2** уже поисковыми шаблонами. Если один из этих поисковых шаблонов сработает, то будет создано уведомление по шаблону **error**.



#### приложения

Наконец ваши собственные задания.

| **Параметр** | **Описание** |
| --- | --- |
| alwaysWork | Булево значение. При **False** проверка, перезапуск и оповещение будет происходить только если процесс активен. |
| doRestart | Булево значение. Используйте **True** чтобы выполнять перезапуск приложений. |
| timeForResta rtingSec | Время в секундах которое отводится на запуск приложения. Если за это время процесс упадёт, то перезапуск считается неудачным. |
| timeForResponse | Время в секундах которое отводится на получение ответа HTTP запроса. Необязательный параметр, по умолчанию значение **10**. |
| checkUrl | Булево значение. Если параметр активен, то при обнаружении процесса AppWatch выполнит HTTP запрос на заданный **url.** |
| url | Любой HTTP запрос приложения который возвращает статус **200**. Если статус будет иным или не будет получен ответ – рестарт приложения. Используется при **checkUrl=true** |
| exe | Название процесса приложения. |
| whatStart | Что нужно запускать:<br>*exe* – запуск исполняемого файла процесса.<br>*command* – выполнение произвольной команды.<br>*service* – запуск службы |
| exePath | Папка нахождения приложения. |
| workDir | Рабочая папка приложения. Не обязательный параметр. См. [WorkDir](#####WorkDir) |
| exeKey | Если нужно запускать приложение с ключами. Используется при **whatStart=exe** |
| command | укажите команду которую можно выполнить в консоли. Используется при **whatStart=command** |
| service | Укажите имя службы. Используется при **whatStart=service** |
| logInspector | Использовать для приложения парсер логов.  См. [Ссылка на парсер логов](####Ссылка на парсер логов) |

Для выполнения команд AppWatch на Windows платформе использует команду:

> start cmd /c **_command_**

На linux платформе:

> command **_command_**  &



##### WorkDir 

workDir используется только для идентификации процесса. Без этого параметра используется **exePath**. Так например, если мониторить два java (JAVA_HOME=**/bin/java**) приложения в папках **/app1** и **/app2**, то процесс и исполняемая папка у них будут одинаковые (*java* и */bin/java*). Задания для них будут такими:

```ini
[app1]
exe=java
workDir=/app1
whatStart=command
command=java -jar /app1/myapp.jar
...

[app2]
exe=java
workDir=/app2
...
```

Если  в задании указать ссылку на парсер логов, то workDir так же будет используется вместо exePath.




##### Ссылка на парсер логов

Для нескольких заданий вы можете указать один парсер логов. Это удобно когда у вас много приложений с одинаковой структурой логирования.

К примеру:

```ini
[app_log]
file = {{appDir}}license.log
templates = lic_error; lic_404

[myApp]
logInspector = app_log
alwayswork = true
exePath = C:\myApp
...

[myApp2]
logInspector = app_log
workPath = C:\myApp2
...
```

Тогда для каждого задания будет дополнительно выполняться **app_log**. Поскольку у каждого приложения своя рабочая папка, то её можно указать переменной `{{appDir}}`. Если для какого-то приложения сработает app_log, то <u>уведомление будет сформировано от имени приложения, а не от парсера логов.</u>

------

[https://github.com/justtopich/AppWatch](https://github.com/justtopich/AppWatch)